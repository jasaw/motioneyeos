commit ff55aecd6fb88a030790b494dcd55bd99cace52b
Author: Joo Aun Saw <jasaw@dius.com.au>
Date:   Mon Sep 18 16:25:44 2017 +1000

    drain codec at end of recording

diff --git a/ffmpeg.c b/ffmpeg.c
index aa06bef..ecdc3e5 100644
--- a/ffmpeg.c
+++ b/ffmpeg.c
@@ -350,7 +350,7 @@ static int ffmpeg_write_packet(struct ffmpeg *ffmpeg){
     }
 }
 
-static int ffmpeg_encode_video(struct ffmpeg *ffmpeg){
+static int ffmpeg_encode_video(struct ffmpeg *ffmpeg, AVFrame *picture){
 
 #if (LIBAVFORMAT_VERSION_MAJOR >= 58) || ((LIBAVFORMAT_VERSION_MAJOR == 57) && (LIBAVFORMAT_VERSION_MINOR >= 41))
     //ffmpeg version 3.1 and after
@@ -361,7 +361,7 @@ static int ffmpeg_encode_video(struct ffmpeg *ffmpeg){
     ffmpeg->pkt.data = NULL;
     ffmpeg->pkt.size = 0;
 
-    retcd = avcodec_send_frame(ffmpeg->ctx_codec, ffmpeg->picture);
+    retcd = avcodec_send_frame(ffmpeg->ctx_codec, picture);
     if (retcd < 0 ){
         av_strerror(retcd, errstr, sizeof(errstr));
         MOTION_LOG(ERR, TYPE_ENCODER, NO_ERRNO, "Error sending frame for encoding:%s",errstr);
@@ -370,10 +370,15 @@ static int ffmpeg_encode_video(struct ffmpeg *ffmpeg){
     }
     while (retcd >= 0) {
         retcd = avcodec_receive_packet(ffmpeg->ctx_codec, &ffmpeg->pkt);
-        if (retcd == AVERROR(EAGAIN)){
-            //Buffered packet.  Throw special return code
-            my_packet_unref(ffmpeg->pkt);
-            return -2;
+        if (picture == NULL) {
+            if (retcd == AVERROR_EOF)
+                break;
+        } else {
+            if (retcd == AVERROR(EAGAIN)){
+                //Buffered packet.  Throw special return code
+                my_packet_unref(ffmpeg->pkt);
+                return -2;
+            }
         }
         if (retcd < 0 ){
             av_strerror(retcd, errstr, sizeof(errstr));
@@ -385,7 +390,11 @@ static int ffmpeg_encode_video(struct ffmpeg *ffmpeg){
             if (retcd < 0) {
                 MOTION_LOG(ERR, TYPE_ENCODER, NO_ERRNO, "Error while writing video frame");
                 my_packet_unref(ffmpeg->pkt);
-                ffmpeg_free_context(ffmpeg);
+                /* Do not free ffmpeg context if we are draining codec. We still
+                 * need to write trailer even if draining fails.
+                 */
+                if (picture != NULL)
+                    ffmpeg_free_context(ffmpeg);
                 return -1;
             }
         }
@@ -404,7 +413,7 @@ static int ffmpeg_encode_video(struct ffmpeg *ffmpeg){
     ffmpeg->pkt.data = NULL;
     ffmpeg->pkt.size = 0;
 
-    retcd = avcodec_encode_video2(ffmpeg->ctx_codec, &ffmpeg->pkt, ffmpeg->picture, &got_packet_ptr);
+    retcd = avcodec_encode_video2(ffmpeg->ctx_codec, &ffmpeg->pkt, picture, &got_packet_ptr);
     if (retcd < 0 ){
         av_strerror(retcd, errstr, sizeof(errstr));
         MOTION_LOG(ERR, TYPE_ENCODER, NO_ERRNO, "Error encoding video:%s",errstr);
@@ -421,7 +430,11 @@ static int ffmpeg_encode_video(struct ffmpeg *ffmpeg){
     if (retcd < 0) {
         MOTION_LOG(ERR, TYPE_ENCODER, NO_ERRNO, "Error while writing video frame");
         my_packet_unref(ffmpeg->pkt);
-        ffmpeg_free_context(ffmpeg);
+        /* Do not free ffmpeg context if we are draining codec. We still
+         * need to write trailer even if draining fails.
+         */
+        if (picture != NULL)
+            ffmpeg_free_context(ffmpeg);
         return -1;
     }
 
@@ -441,7 +454,7 @@ static int ffmpeg_encode_video(struct ffmpeg *ffmpeg){
     video_outbuf_size = (ffmpeg->ctx_codec->width +16) * (ffmpeg->ctx_codec->height +16) * 1;
     video_outbuf = mymalloc(video_outbuf_size);
 
-    retcd = avcodec_encode_video(ffmpeg->video_st->codec, video_outbuf, video_outbuf_size, ffmpeg->picture);
+    retcd = avcodec_encode_video(ffmpeg->video_st->codec, video_outbuf, video_outbuf_size, picture);
     if (retcd < 0 ){
         MOTION_LOG(ERR, TYPE_ENCODER, NO_ERRNO, "Error encoding video");
         my_packet_unref(ffmpeg->pkt);
@@ -457,11 +470,12 @@ static int ffmpeg_encode_video(struct ffmpeg *ffmpeg){
     ffmpeg->pkt.size = retcd;
     ffmpeg->pkt.data = video_outbuf;
 
-    if (ffmpeg->picture->key_frame == 1)
-      ffmpeg->pkt.flags |= AV_PKT_FLAG_KEY;
-
-    ffmpeg->pkt.pts = ffmpeg->picture->pts;
-    ffmpeg->pkt.dts = ffmpeg->pkt.pts;
+    if (picture) {
+        if (picture->key_frame == 1)
+          ffmpeg->pkt.flags |= AV_PKT_FLAG_KEY;
+        ffmpeg->pkt.pts = picture->pts;
+        ffmpeg->pkt.dts = ffmpeg->pkt.pts;
+    }
 
     retcd = ffmpeg_write_packet(ffmpeg);
     if (retcd < 0) {
@@ -469,7 +483,11 @@ static int ffmpeg_encode_video(struct ffmpeg *ffmpeg){
         MOTION_LOG(ERR, TYPE_ENCODER, NO_ERRNO, "Error while writing video frame");
         my_packet_unref(ffmpeg->pkt);
         free(video_outbuf);
-        ffmpeg_free_context(ffmpeg);
+        /* Do not free ffmpeg context if we are draining codec. We still
+         * need to write trailer even if draining fails.
+         */
+        if (picture != NULL)
+            ffmpeg_free_context(ffmpeg);
         return -1;
     }
 
@@ -817,7 +835,7 @@ static int ffmpeg_put_frame(struct ffmpeg *ffmpeg, const struct timeval *tv1){
         return 0;
     }
 
-    retcd = ffmpeg_encode_video(ffmpeg);
+    retcd = ffmpeg_encode_video(ffmpeg, ffmpeg->picture);
     if (retcd < 0){
         if (retcd != -2)
             MOTION_LOG(ERR, TYPE_ENCODER, NO_ERRNO, "Error while encoding picture");
@@ -957,6 +975,7 @@ void ffmpeg_close(struct ffmpeg *ffmpeg){
 #ifdef HAVE_FFMPEG
 
     if (ffmpeg != NULL) {
+        ffmpeg_encode_video(ffmpeg, NULL); // drain codec
         if (ffmpeg->tlapse != TIMELAPSE_APPEND) {
             av_write_trailer(ffmpeg->oc);
         }
